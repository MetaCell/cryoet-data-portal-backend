type Alignment implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  annotationFiles(
    where: AnnotationFileWhereClause = null
    orderBy: [AnnotationFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationFileConnection!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate
  perSectionAlignments(
    where: PerSectionAlignmentParametersWhereClause = null
    orderBy: [PerSectionAlignmentParametersOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): PerSectionAlignmentParametersConnection!
  perSectionAlignmentsAggregate(where: PerSectionAlignmentParametersWhereClause = null): PerSectionAlignmentParametersAggregate
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  tiltseries(where: TiltseriesWhereClause = null, orderBy: [TiltseriesOrderByClause!] = []): Tiltseries
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  alignment: String!
  alignmentType: alignment_type_enum
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  volumeXRotation: Float
  tiltOffset: Float
  localAlignmentFile: String
}

type AlignmentAggregate {
  aggregate: [AlignmentAggregateFunctions!]
}

type AlignmentAggregateFunctions {
  sum: AlignmentNumericalColumns
  avg: AlignmentNumericalColumns
  stddev: AlignmentNumericalColumns
  variance: AlignmentNumericalColumns
  min: AlignmentMinMaxColumns
  max: AlignmentMinMaxColumns
  groupBy: AlignmentGroupByOptions
  count(distinct: Boolean = false, columns: AlignmentCountColumns = null): Int
}

"""A connection to a list of items."""
type AlignmentConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AlignmentEdge!]!
}

enum AlignmentCountColumns {
  annotationFiles
  perSectionAlignments
  deposition
  tiltseries
  tomograms
  run
  alignment
  alignmentType
  volumeXDimension
  volumeYDimension
  volumeZDimension
  volumeXOffset
  volumeYOffset
  volumeZOffset
  volumeXRotation
  tiltOffset
  localAlignmentFile
  id
}

input AlignmentCreateInput {
  depositionId: ID = null
  tiltseriesId: ID = null
  runId: ID = null
  alignment: String!
  alignmentType: alignment_type_enum = null
  volumeXDimension: Float = null
  volumeYDimension: Float = null
  volumeZDimension: Float = null
  volumeXOffset: Float = null
  volumeYOffset: Float = null
  volumeZOffset: Float = null
  volumeXRotation: Float = null
  tiltOffset: Float = null
  localAlignmentFile: String = null
  id: Int!
}

"""An edge in a connection."""
type AlignmentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Alignment!
}

type AlignmentGroupByOptions {
  deposition: DepositionGroupByOptions
  tiltseries: TiltseriesGroupByOptions
  run: RunGroupByOptions
  alignment: String
  alignmentType: alignment_type_enum
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  volumeXRotation: Float
  tiltOffset: Float
  localAlignmentFile: String
  id: Int
}

type AlignmentMinMaxColumns {
  alignment: String
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  volumeXRotation: Float
  tiltOffset: Float
  localAlignmentFile: String
  id: Int
}

type AlignmentNumericalColumns {
  volumeXDimension: Float
  volumeYDimension: Float
  volumeZDimension: Float
  volumeXOffset: Float
  volumeYOffset: Float
  volumeZOffset: Float
  volumeXRotation: Float
  tiltOffset: Float
  id: Int
}

input AlignmentOrderByClause {
  deposition: DepositionOrderByClause
  tiltseries: TiltseriesOrderByClause
  run: RunOrderByClause
  alignment: orderBy
  alignmentType: orderBy
  volumeXDimension: orderBy
  volumeYDimension: orderBy
  volumeZDimension: orderBy
  volumeXOffset: orderBy
  volumeYOffset: orderBy
  volumeZOffset: orderBy
  volumeXRotation: orderBy
  tiltOffset: orderBy
  localAlignmentFile: orderBy
  id: orderBy
}

input AlignmentUpdateInput {
  depositionId: ID = null
  tiltseriesId: ID = null
  runId: ID = null
  alignment: String = null
  alignmentType: alignment_type_enum = null
  volumeXDimension: Float = null
  volumeYDimension: Float = null
  volumeZDimension: Float = null
  volumeXOffset: Float = null
  volumeYOffset: Float = null
  volumeZOffset: Float = null
  volumeXRotation: Float = null
  tiltOffset: Float = null
  localAlignmentFile: String = null
  id: Int = null
}

input AlignmentWhereClause {
  annotationFiles: AnnotationFileWhereClause
  perSectionAlignments: PerSectionAlignmentParametersWhereClause
  deposition: DepositionWhereClause
  tiltseries: TiltseriesWhereClause
  tomograms: TomogramWhereClause
  run: RunWhereClause
  alignment: StrComparators
  alignmentType: Alignment_type_enumEnumComparators
  volumeXDimension: FloatComparators
  volumeYDimension: FloatComparators
  volumeZDimension: FloatComparators
  volumeXOffset: FloatComparators
  volumeYOffset: FloatComparators
  volumeZOffset: FloatComparators
  volumeXRotation: FloatComparators
  tiltOffset: FloatComparators
  localAlignmentFile: StrComparators
  id: IntComparators
}

input AlignmentWhereClauseMutations {
  id: IntComparators
}

input Alignment_type_enumEnumComparators {
  _eq: alignment_type_enum
  _neq: alignment_type_enum
  _in: [alignment_type_enum!]
  _nin: [alignment_type_enum!]
  _gt: alignment_type_enum
  _gte: alignment_type_enum
  _lt: alignment_type_enum
  _lte: alignment_type_enum
  _is_null: Boolean
}

type Annotation implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  annotationShapes(
    where: AnnotationShapeWhereClause = null
    orderBy: [AnnotationShapeOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationShapeConnection!
  annotationShapesAggregate(where: AnnotationShapeWhereClause = null): AnnotationShapeAggregate
  authors(
    where: AnnotationAuthorWhereClause = null
    orderBy: [AnnotationAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationAuthorConnection!
  authorsAggregate(where: AnnotationAuthorWhereClause = null): AnnotationAuthorAggregate
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  s3MetadataPath: String!
  httpsMetadataPath: String!
  annotationPublication: String
  annotationMethod: String!
  groundTruthStatus: Boolean
  objectId: String!
  objectName: String!
  objectDescription: String
  objectState: String
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  groundTruthUsed: String
  annotationSoftware: String
  isCuratorRecommended: Boolean
  methodType: annotation_method_type_enum!
  depositionDate: DateTime!
  releaseDate: DateTime!
  lastModifiedDate: DateTime!
}

type AnnotationAggregate {
  aggregate: [AnnotationAggregateFunctions!]
}

type AnnotationAggregateFunctions {
  sum: AnnotationNumericalColumns
  avg: AnnotationNumericalColumns
  stddev: AnnotationNumericalColumns
  variance: AnnotationNumericalColumns
  min: AnnotationMinMaxColumns
  max: AnnotationMinMaxColumns
  groupBy: AnnotationGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationCountColumns = null): Int
}

type AnnotationAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  annotation(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = []): Annotation
  authorListOrder: Int!
  orcid: String
  name: String!
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

type AnnotationAuthorAggregate {
  aggregate: [AnnotationAuthorAggregateFunctions!]
}

type AnnotationAuthorAggregateFunctions {
  sum: AnnotationAuthorNumericalColumns
  avg: AnnotationAuthorNumericalColumns
  stddev: AnnotationAuthorNumericalColumns
  variance: AnnotationAuthorNumericalColumns
  min: AnnotationAuthorMinMaxColumns
  max: AnnotationAuthorMinMaxColumns
  groupBy: AnnotationAuthorGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationAuthorCountColumns = null): Int
}

"""A connection to a list of items."""
type AnnotationAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationAuthorEdge!]!
}

enum AnnotationAuthorCountColumns {
  annotation
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
  id
}

input AnnotationAuthorCreateInput {
  annotationId: ID = null
  authorListOrder: Int!
  orcid: String = null
  name: String!
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  id: Int!
}

"""An edge in a connection."""
type AnnotationAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationAuthor!
}

type AnnotationAuthorGroupByOptions {
  annotation: AnnotationGroupByOptions
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
  id: Int
}

type AnnotationAuthorMinMaxColumns {
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  id: Int
}

type AnnotationAuthorNumericalColumns {
  authorListOrder: Int
  id: Int
}

input AnnotationAuthorOrderByClause {
  annotation: AnnotationOrderByClause
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
  id: orderBy
}

input AnnotationAuthorUpdateInput {
  annotationId: ID = null
  authorListOrder: Int = null
  orcid: String = null
  name: String = null
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  id: Int = null
}

input AnnotationAuthorWhereClause {
  annotation: AnnotationWhereClause
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
  id: IntComparators
}

input AnnotationAuthorWhereClauseMutations {
  id: IntComparators
}

"""A connection to a list of items."""
type AnnotationConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationEdge!]!
}

enum AnnotationCountColumns {
  run
  annotationShapes
  authors
  deposition
  s3MetadataPath
  httpsMetadataPath
  annotationPublication
  annotationMethod
  groundTruthStatus
  objectId
  objectName
  objectDescription
  objectState
  objectCount
  confidencePrecision
  confidenceRecall
  groundTruthUsed
  annotationSoftware
  isCuratorRecommended
  methodType
  depositionDate
  releaseDate
  lastModifiedDate
  id
}

input AnnotationCreateInput {
  runId: ID = null
  depositionId: ID = null
  s3MetadataPath: String!
  httpsMetadataPath: String!
  annotationPublication: String = null
  annotationMethod: String!
  groundTruthStatus: Boolean = null
  objectId: String!
  objectName: String!
  objectDescription: String = null
  objectState: String = null
  objectCount: Int = null
  confidencePrecision: Float = null
  confidenceRecall: Float = null
  groundTruthUsed: String = null
  annotationSoftware: String = null
  isCuratorRecommended: Boolean = null
  methodType: annotation_method_type_enum!
  depositionDate: DateTime!
  releaseDate: DateTime!
  lastModifiedDate: DateTime!
  id: Int!
}

"""An edge in a connection."""
type AnnotationEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Annotation!
}

type AnnotationFile implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  alignment(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = []): Alignment
  annotationShape(where: AnnotationShapeWhereClause = null, orderBy: [AnnotationShapeOrderByClause!] = []): AnnotationShape
  tomogramVoxelSpacing(where: TomogramVoxelSpacingWhereClause = null, orderBy: [TomogramVoxelSpacingOrderByClause!] = []): TomogramVoxelSpacing
  format: String!
  s3Path: String!
  httpsPath: String!
  isVisualizationDefault: Boolean
  source: annotation_file_source_enum
}

type AnnotationFileAggregate {
  aggregate: [AnnotationFileAggregateFunctions!]
}

type AnnotationFileAggregateFunctions {
  sum: AnnotationFileNumericalColumns
  avg: AnnotationFileNumericalColumns
  stddev: AnnotationFileNumericalColumns
  variance: AnnotationFileNumericalColumns
  min: AnnotationFileMinMaxColumns
  max: AnnotationFileMinMaxColumns
  groupBy: AnnotationFileGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationFileCountColumns = null): Int
}

"""A connection to a list of items."""
type AnnotationFileConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationFileEdge!]!
}

enum AnnotationFileCountColumns {
  alignment
  annotationShape
  tomogramVoxelSpacing
  format
  s3Path
  httpsPath
  isVisualizationDefault
  source
  id
}

input AnnotationFileCreateInput {
  alignmentId: ID = null
  annotationShapeId: ID = null
  tomogramVoxelSpacingId: ID = null
  format: String!
  s3Path: String!
  httpsPath: String!
  isVisualizationDefault: Boolean = null
  source: annotation_file_source_enum = null
  id: Int!
}

"""An edge in a connection."""
type AnnotationFileEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationFile!
}

type AnnotationFileGroupByOptions {
  alignment: AlignmentGroupByOptions
  annotationShape: AnnotationShapeGroupByOptions
  tomogramVoxelSpacing: TomogramVoxelSpacingGroupByOptions
  format: String
  s3Path: String
  httpsPath: String
  isVisualizationDefault: Boolean
  source: annotation_file_source_enum
  id: Int
}

type AnnotationFileMinMaxColumns {
  format: String
  s3Path: String
  httpsPath: String
  id: Int
}

type AnnotationFileNumericalColumns {
  id: Int
}

input AnnotationFileOrderByClause {
  alignment: AlignmentOrderByClause
  annotationShape: AnnotationShapeOrderByClause
  tomogramVoxelSpacing: TomogramVoxelSpacingOrderByClause
  format: orderBy
  s3Path: orderBy
  httpsPath: orderBy
  isVisualizationDefault: orderBy
  source: orderBy
  id: orderBy
}

input AnnotationFileUpdateInput {
  alignmentId: ID = null
  annotationShapeId: ID = null
  tomogramVoxelSpacingId: ID = null
  format: String = null
  s3Path: String = null
  httpsPath: String = null
  isVisualizationDefault: Boolean = null
  source: annotation_file_source_enum = null
  id: Int = null
}

input AnnotationFileWhereClause {
  alignment: AlignmentWhereClause
  annotationShape: AnnotationShapeWhereClause
  tomogramVoxelSpacing: TomogramVoxelSpacingWhereClause
  format: StrComparators
  s3Path: StrComparators
  httpsPath: StrComparators
  isVisualizationDefault: BoolComparators
  source: Annotation_file_source_enumEnumComparators
  id: IntComparators
}

input AnnotationFileWhereClauseMutations {
  id: IntComparators
}

type AnnotationGroupByOptions {
  run: RunGroupByOptions
  deposition: DepositionGroupByOptions
  s3MetadataPath: String
  httpsMetadataPath: String
  annotationPublication: String
  annotationMethod: String
  groundTruthStatus: Boolean
  objectId: String
  objectName: String
  objectDescription: String
  objectState: String
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  groundTruthUsed: String
  annotationSoftware: String
  isCuratorRecommended: Boolean
  methodType: annotation_method_type_enum
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  id: Int
}

type AnnotationMinMaxColumns {
  s3MetadataPath: String
  httpsMetadataPath: String
  annotationPublication: String
  annotationMethod: String
  objectId: String
  objectName: String
  objectDescription: String
  objectState: String
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  groundTruthUsed: String
  annotationSoftware: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  id: Int
}

type AnnotationNumericalColumns {
  objectCount: Int
  confidencePrecision: Float
  confidenceRecall: Float
  id: Int
}

input AnnotationOrderByClause {
  run: RunOrderByClause
  deposition: DepositionOrderByClause
  s3MetadataPath: orderBy
  httpsMetadataPath: orderBy
  annotationPublication: orderBy
  annotationMethod: orderBy
  groundTruthStatus: orderBy
  objectId: orderBy
  objectName: orderBy
  objectDescription: orderBy
  objectState: orderBy
  objectCount: orderBy
  confidencePrecision: orderBy
  confidenceRecall: orderBy
  groundTruthUsed: orderBy
  annotationSoftware: orderBy
  isCuratorRecommended: orderBy
  methodType: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
  id: orderBy
}

type AnnotationShape implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  annotation(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = []): Annotation
  annotationFiles(
    where: AnnotationFileWhereClause = null
    orderBy: [AnnotationFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationFileConnection!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate
  shapeType: annotation_file_shape_type_enum
}

type AnnotationShapeAggregate {
  aggregate: [AnnotationShapeAggregateFunctions!]
}

type AnnotationShapeAggregateFunctions {
  sum: AnnotationShapeNumericalColumns
  avg: AnnotationShapeNumericalColumns
  stddev: AnnotationShapeNumericalColumns
  variance: AnnotationShapeNumericalColumns
  min: AnnotationShapeMinMaxColumns
  max: AnnotationShapeMinMaxColumns
  groupBy: AnnotationShapeGroupByOptions
  count(distinct: Boolean = false, columns: AnnotationShapeCountColumns = null): Int
}

"""A connection to a list of items."""
type AnnotationShapeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [AnnotationShapeEdge!]!
}

enum AnnotationShapeCountColumns {
  annotation
  annotationFiles
  shapeType
  id
}

input AnnotationShapeCreateInput {
  annotationId: ID = null
  shapeType: annotation_file_shape_type_enum = null
  id: Int!
}

"""An edge in a connection."""
type AnnotationShapeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: AnnotationShape!
}

type AnnotationShapeGroupByOptions {
  annotation: AnnotationGroupByOptions
  shapeType: annotation_file_shape_type_enum
  id: Int
}

type AnnotationShapeMinMaxColumns {
  id: Int
}

type AnnotationShapeNumericalColumns {
  id: Int
}

input AnnotationShapeOrderByClause {
  annotation: AnnotationOrderByClause
  shapeType: orderBy
  id: orderBy
}

input AnnotationShapeUpdateInput {
  annotationId: ID = null
  shapeType: annotation_file_shape_type_enum = null
  id: Int = null
}

input AnnotationShapeWhereClause {
  annotation: AnnotationWhereClause
  annotationFiles: AnnotationFileWhereClause
  shapeType: Annotation_file_shape_type_enumEnumComparators
  id: IntComparators
}

input AnnotationShapeWhereClauseMutations {
  id: IntComparators
}

input AnnotationUpdateInput {
  runId: ID = null
  depositionId: ID = null
  s3MetadataPath: String = null
  httpsMetadataPath: String = null
  annotationPublication: String = null
  annotationMethod: String = null
  groundTruthStatus: Boolean = null
  objectId: String = null
  objectName: String = null
  objectDescription: String = null
  objectState: String = null
  objectCount: Int = null
  confidencePrecision: Float = null
  confidenceRecall: Float = null
  groundTruthUsed: String = null
  annotationSoftware: String = null
  isCuratorRecommended: Boolean = null
  methodType: annotation_method_type_enum = null
  depositionDate: DateTime = null
  releaseDate: DateTime = null
  lastModifiedDate: DateTime = null
  id: Int = null
}

input AnnotationWhereClause {
  run: RunWhereClause
  annotationShapes: AnnotationShapeWhereClause
  authors: AnnotationAuthorWhereClause
  deposition: DepositionWhereClause
  s3MetadataPath: StrComparators
  httpsMetadataPath: StrComparators
  annotationPublication: StrComparators
  annotationMethod: StrComparators
  groundTruthStatus: BoolComparators
  objectId: StrComparators
  objectName: StrComparators
  objectDescription: StrComparators
  objectState: StrComparators
  objectCount: IntComparators
  confidencePrecision: FloatComparators
  confidenceRecall: FloatComparators
  groundTruthUsed: StrComparators
  annotationSoftware: StrComparators
  isCuratorRecommended: BoolComparators
  methodType: Annotation_method_type_enumEnumComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
  id: IntComparators
}

input AnnotationWhereClauseMutations {
  id: IntComparators
}

input Annotation_file_shape_type_enumEnumComparators {
  _eq: annotation_file_shape_type_enum
  _neq: annotation_file_shape_type_enum
  _in: [annotation_file_shape_type_enum!]
  _nin: [annotation_file_shape_type_enum!]
  _gt: annotation_file_shape_type_enum
  _gte: annotation_file_shape_type_enum
  _lt: annotation_file_shape_type_enum
  _lte: annotation_file_shape_type_enum
  _is_null: Boolean
}

input Annotation_file_source_enumEnumComparators {
  _eq: annotation_file_source_enum
  _neq: annotation_file_source_enum
  _in: [annotation_file_source_enum!]
  _nin: [annotation_file_source_enum!]
  _gt: annotation_file_source_enum
  _gte: annotation_file_source_enum
  _lt: annotation_file_source_enum
  _lte: annotation_file_source_enum
  _is_null: Boolean
}

input Annotation_method_type_enumEnumComparators {
  _eq: annotation_method_type_enum
  _neq: annotation_method_type_enum
  _in: [annotation_method_type_enum!]
  _nin: [annotation_method_type_enum!]
  _gt: annotation_method_type_enum
  _gte: annotation_method_type_enum
  _lt: annotation_method_type_enum
  _lte: annotation_method_type_enum
  _is_null: Boolean
}

input BoolComparators {
  _eq: Int
  _neq: Int
  _in: [Int!]
  _nin: [Int!]
  _gt: Int
  _gte: Int
  _lt: Int
  _lte: Int
  _is_null: Boolean
}

type Dataset implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  fundingSources(
    where: DatasetFundingWhereClause = null
    orderBy: [DatasetFundingOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DatasetFundingConnection!
  fundingSourcesAggregate(where: DatasetFundingWhereClause = null): DatasetFundingAggregate
  authors(
    where: DatasetAuthorWhereClause = null
    orderBy: [DatasetAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DatasetAuthorConnection!
  authorsAggregate(where: DatasetAuthorWhereClause = null): DatasetAuthorAggregate
  runs(
    where: RunWhereClause = null
    orderBy: [RunOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): RunConnection!
  runsAggregate(where: RunWhereClause = null): RunAggregate
  title: String!
  description: String!
  organismName: String!
  organismTaxid: Int
  tissueName: String
  tissueId: String
  cellName: String
  cellTypeId: String
  cellStrainName: String!
  cellStrainId: String
  sampleType: sample_type_enum
  samplePreparation: String
  gridPreparation: String
  otherSetup: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  cellComponentName: String
  cellComponentId: String
  depositionDate: DateTime!
  releaseDate: DateTime!
  lastModifiedDate: DateTime!
  publications: String
  relatedDatabaseEntries: String
  relatedDatabaseLinks: String
  datasetCitations: String
  s3Prefix: String!
  httpsPrefix: String!
}

type DatasetAggregate {
  aggregate: [DatasetAggregateFunctions!]
}

type DatasetAggregateFunctions {
  sum: DatasetNumericalColumns
  avg: DatasetNumericalColumns
  stddev: DatasetNumericalColumns
  variance: DatasetNumericalColumns
  min: DatasetMinMaxColumns
  max: DatasetMinMaxColumns
  groupBy: DatasetGroupByOptions
  count(distinct: Boolean = false, columns: DatasetCountColumns = null): Int
}

type DatasetAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  dataset(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = []): Dataset
  authorListOrder: Int!
  name: String!
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
  orcid: String
}

type DatasetAuthorAggregate {
  aggregate: [DatasetAuthorAggregateFunctions!]
}

type DatasetAuthorAggregateFunctions {
  sum: DatasetAuthorNumericalColumns
  avg: DatasetAuthorNumericalColumns
  stddev: DatasetAuthorNumericalColumns
  variance: DatasetAuthorNumericalColumns
  min: DatasetAuthorMinMaxColumns
  max: DatasetAuthorMinMaxColumns
  groupBy: DatasetAuthorGroupByOptions
  count(distinct: Boolean = false, columns: DatasetAuthorCountColumns = null): Int
}

"""A connection to a list of items."""
type DatasetAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DatasetAuthorEdge!]!
}

enum DatasetAuthorCountColumns {
  dataset
  authorListOrder
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
  orcid
  id
}

input DatasetAuthorCreateInput {
  datasetId: ID = null
  authorListOrder: Int!
  name: String!
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  orcid: String = null
  id: Int!
}

"""An edge in a connection."""
type DatasetAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DatasetAuthor!
}

type DatasetAuthorGroupByOptions {
  dataset: DatasetGroupByOptions
  authorListOrder: Int
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
  orcid: String
  id: Int
}

type DatasetAuthorMinMaxColumns {
  authorListOrder: Int
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  orcid: String
  id: Int
}

type DatasetAuthorNumericalColumns {
  authorListOrder: Int
  id: Int
}

input DatasetAuthorOrderByClause {
  dataset: DatasetOrderByClause
  authorListOrder: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
  orcid: orderBy
  id: orderBy
}

input DatasetAuthorUpdateInput {
  datasetId: ID = null
  authorListOrder: Int = null
  name: String = null
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  orcid: String = null
  id: Int = null
}

input DatasetAuthorWhereClause {
  dataset: DatasetWhereClause
  authorListOrder: IntComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
  orcid: StrComparators
  id: IntComparators
}

input DatasetAuthorWhereClauseMutations {
  id: IntComparators
}

"""A connection to a list of items."""
type DatasetConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DatasetEdge!]!
}

enum DatasetCountColumns {
  deposition
  fundingSources
  authors
  runs
  title
  description
  organismName
  organismTaxid
  tissueName
  tissueId
  cellName
  cellTypeId
  cellStrainName
  cellStrainId
  sampleType
  samplePreparation
  gridPreparation
  otherSetup
  keyPhotoUrl
  keyPhotoThumbnailUrl
  cellComponentName
  cellComponentId
  depositionDate
  releaseDate
  lastModifiedDate
  publications
  relatedDatabaseEntries
  relatedDatabaseLinks
  datasetCitations
  s3Prefix
  httpsPrefix
  id
}

input DatasetCreateInput {
  depositionId: ID = null
  title: String!
  description: String!
  organismName: String!
  organismTaxid: Int = null
  tissueName: String = null
  tissueId: String = null
  cellName: String = null
  cellTypeId: String = null
  cellStrainName: String!
  cellStrainId: String = null
  sampleType: sample_type_enum = null
  samplePreparation: String = null
  gridPreparation: String = null
  otherSetup: String = null
  keyPhotoUrl: String = null
  keyPhotoThumbnailUrl: String = null
  cellComponentName: String = null
  cellComponentId: String = null
  depositionDate: DateTime!
  releaseDate: DateTime!
  lastModifiedDate: DateTime!
  publications: String = null
  relatedDatabaseEntries: String = null
  relatedDatabaseLinks: String = null
  datasetCitations: String = null
  s3Prefix: String!
  httpsPrefix: String!
  id: Int!
}

"""An edge in a connection."""
type DatasetEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Dataset!
}

type DatasetFunding implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  dataset(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = []): Dataset
  fundingAgencyName: String
  grantId: String
}

type DatasetFundingAggregate {
  aggregate: [DatasetFundingAggregateFunctions!]
}

type DatasetFundingAggregateFunctions {
  sum: DatasetFundingNumericalColumns
  avg: DatasetFundingNumericalColumns
  stddev: DatasetFundingNumericalColumns
  variance: DatasetFundingNumericalColumns
  min: DatasetFundingMinMaxColumns
  max: DatasetFundingMinMaxColumns
  groupBy: DatasetFundingGroupByOptions
  count(distinct: Boolean = false, columns: DatasetFundingCountColumns = null): Int
}

"""A connection to a list of items."""
type DatasetFundingConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DatasetFundingEdge!]!
}

enum DatasetFundingCountColumns {
  dataset
  fundingAgencyName
  grantId
  id
}

input DatasetFundingCreateInput {
  datasetId: ID = null
  fundingAgencyName: String = null
  grantId: String = null
  id: Int!
}

"""An edge in a connection."""
type DatasetFundingEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DatasetFunding!
}

type DatasetFundingGroupByOptions {
  dataset: DatasetGroupByOptions
  fundingAgencyName: String
  grantId: String
  id: Int
}

type DatasetFundingMinMaxColumns {
  fundingAgencyName: String
  grantId: String
  id: Int
}

type DatasetFundingNumericalColumns {
  id: Int
}

input DatasetFundingOrderByClause {
  dataset: DatasetOrderByClause
  fundingAgencyName: orderBy
  grantId: orderBy
  id: orderBy
}

input DatasetFundingUpdateInput {
  datasetId: ID = null
  fundingAgencyName: String = null
  grantId: String = null
  id: Int = null
}

input DatasetFundingWhereClause {
  dataset: DatasetWhereClause
  fundingAgencyName: StrComparators
  grantId: StrComparators
  id: IntComparators
}

input DatasetFundingWhereClauseMutations {
  id: IntComparators
}

type DatasetGroupByOptions {
  deposition: DepositionGroupByOptions
  title: String
  description: String
  organismName: String
  organismTaxid: Int
  tissueName: String
  tissueId: String
  cellName: String
  cellTypeId: String
  cellStrainName: String
  cellStrainId: String
  sampleType: sample_type_enum
  samplePreparation: String
  gridPreparation: String
  otherSetup: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  cellComponentName: String
  cellComponentId: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  publications: String
  relatedDatabaseEntries: String
  relatedDatabaseLinks: String
  datasetCitations: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type DatasetMinMaxColumns {
  title: String
  description: String
  organismName: String
  organismTaxid: Int
  tissueName: String
  tissueId: String
  cellName: String
  cellTypeId: String
  cellStrainName: String
  cellStrainId: String
  samplePreparation: String
  gridPreparation: String
  otherSetup: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  cellComponentName: String
  cellComponentId: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  publications: String
  relatedDatabaseEntries: String
  relatedDatabaseLinks: String
  datasetCitations: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type DatasetNumericalColumns {
  organismTaxid: Int
  id: Int
}

input DatasetOrderByClause {
  deposition: DepositionOrderByClause
  title: orderBy
  description: orderBy
  organismName: orderBy
  organismTaxid: orderBy
  tissueName: orderBy
  tissueId: orderBy
  cellName: orderBy
  cellTypeId: orderBy
  cellStrainName: orderBy
  cellStrainId: orderBy
  sampleType: orderBy
  samplePreparation: orderBy
  gridPreparation: orderBy
  otherSetup: orderBy
  keyPhotoUrl: orderBy
  keyPhotoThumbnailUrl: orderBy
  cellComponentName: orderBy
  cellComponentId: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
  publications: orderBy
  relatedDatabaseEntries: orderBy
  relatedDatabaseLinks: orderBy
  datasetCitations: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

input DatasetUpdateInput {
  depositionId: ID = null
  title: String = null
  description: String = null
  organismName: String = null
  organismTaxid: Int = null
  tissueName: String = null
  tissueId: String = null
  cellName: String = null
  cellTypeId: String = null
  cellStrainName: String = null
  cellStrainId: String = null
  sampleType: sample_type_enum = null
  samplePreparation: String = null
  gridPreparation: String = null
  otherSetup: String = null
  keyPhotoUrl: String = null
  keyPhotoThumbnailUrl: String = null
  cellComponentName: String = null
  cellComponentId: String = null
  depositionDate: DateTime = null
  releaseDate: DateTime = null
  lastModifiedDate: DateTime = null
  publications: String = null
  relatedDatabaseEntries: String = null
  relatedDatabaseLinks: String = null
  datasetCitations: String = null
  s3Prefix: String = null
  httpsPrefix: String = null
  id: Int = null
}

input DatasetWhereClause {
  deposition: DepositionWhereClause
  fundingSources: DatasetFundingWhereClause
  authors: DatasetAuthorWhereClause
  runs: RunWhereClause
  title: StrComparators
  description: StrComparators
  organismName: StrComparators
  organismTaxid: IntComparators
  tissueName: StrComparators
  tissueId: StrComparators
  cellName: StrComparators
  cellTypeId: StrComparators
  cellStrainName: StrComparators
  cellStrainId: StrComparators
  sampleType: Sample_type_enumEnumComparators
  samplePreparation: StrComparators
  gridPreparation: StrComparators
  otherSetup: StrComparators
  keyPhotoUrl: StrComparators
  keyPhotoThumbnailUrl: StrComparators
  cellComponentName: StrComparators
  cellComponentId: StrComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
  publications: StrComparators
  relatedDatabaseEntries: StrComparators
  relatedDatabaseLinks: StrComparators
  datasetCitations: StrComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input DatasetWhereClauseMutations {
  id: IntComparators
}

"""Date with time (isoformat)"""
scalar DateTime

input DatetimeComparators {
  _eq: DateTime
  _neq: DateTime
  _in: [DateTime!]
  _nin: [DateTime!]
  _gt: DateTime
  _gte: DateTime
  _lt: DateTime
  _lte: DateTime
  _is_null: Boolean
}

type Deposition implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  authors(
    where: DepositionAuthorWhereClause = null
    orderBy: [DepositionAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DepositionAuthorConnection!
  authorsAggregate(where: DepositionAuthorWhereClause = null): DepositionAuthorAggregate
  alignments(
    where: AlignmentWhereClause = null
    orderBy: [AlignmentOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AlignmentConnection!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate
  annotations(
    where: AnnotationWhereClause = null
    orderBy: [AnnotationOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationConnection!
  annotationsAggregate(where: AnnotationWhereClause = null): AnnotationAggregate
  datasets(
    where: DatasetWhereClause = null
    orderBy: [DatasetOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DatasetConnection!
  datasetsAggregate(where: DatasetWhereClause = null): DatasetAggregate
  frames(
    where: FrameWhereClause = null
    orderBy: [FrameOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): FrameConnection!
  framesAggregate(where: FrameWhereClause = null): FrameAggregate
  tiltseries(
    where: TiltseriesWhereClause = null
    orderBy: [TiltseriesOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TiltseriesConnection!
  tiltseriesAggregate(where: TiltseriesWhereClause = null): TiltseriesAggregate
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate
  depositionTitle: String!
  depositionDescription: String!
  depositionTypes(
    where: DepositionTypeWhereClause = null
    orderBy: [DepositionTypeOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): DepositionTypeConnection!
  depositionTypesAggregate(where: DepositionTypeWhereClause = null): DepositionTypeAggregate
  publications: String
  relatedDatabaseEntries: String
  relatedDatabaseLinks: String
  datasetCitations: String
  depositionDate: DateTime!
  releaseDate: DateTime!
  lastModifiedDate: DateTime!
}

type DepositionAggregate {
  aggregate: [DepositionAggregateFunctions!]
}

type DepositionAggregateFunctions {
  sum: DepositionNumericalColumns
  avg: DepositionNumericalColumns
  stddev: DepositionNumericalColumns
  variance: DepositionNumericalColumns
  min: DepositionMinMaxColumns
  max: DepositionMinMaxColumns
  groupBy: DepositionGroupByOptions
  count(distinct: Boolean = false, columns: DepositionCountColumns = null): Int
}

type DepositionAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  authorListOrder: Int!
  orcid: String
  name: String!
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

type DepositionAuthorAggregate {
  aggregate: [DepositionAuthorAggregateFunctions!]
}

type DepositionAuthorAggregateFunctions {
  sum: DepositionAuthorNumericalColumns
  avg: DepositionAuthorNumericalColumns
  stddev: DepositionAuthorNumericalColumns
  variance: DepositionAuthorNumericalColumns
  min: DepositionAuthorMinMaxColumns
  max: DepositionAuthorMinMaxColumns
  groupBy: DepositionAuthorGroupByOptions
  count(distinct: Boolean = false, columns: DepositionAuthorCountColumns = null): Int
}

"""A connection to a list of items."""
type DepositionAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DepositionAuthorEdge!]!
}

enum DepositionAuthorCountColumns {
  deposition
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
  id
}

input DepositionAuthorCreateInput {
  depositionId: ID = null
  authorListOrder: Int!
  orcid: String = null
  name: String!
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  id: Int!
}

"""An edge in a connection."""
type DepositionAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DepositionAuthor!
}

type DepositionAuthorGroupByOptions {
  deposition: DepositionGroupByOptions
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
  id: Int
}

type DepositionAuthorMinMaxColumns {
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  id: Int
}

type DepositionAuthorNumericalColumns {
  authorListOrder: Int
  id: Int
}

input DepositionAuthorOrderByClause {
  deposition: DepositionOrderByClause
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
  id: orderBy
}

input DepositionAuthorUpdateInput {
  depositionId: ID = null
  authorListOrder: Int = null
  orcid: String = null
  name: String = null
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  id: Int = null
}

input DepositionAuthorWhereClause {
  deposition: DepositionWhereClause
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
  id: IntComparators
}

input DepositionAuthorWhereClauseMutations {
  id: IntComparators
}

enum DepositionCountColumns {
  authors
  alignments
  annotations
  datasets
  frames
  tiltseries
  tomograms
  depositionTitle
  depositionDescription
  depositionTypes
  publications
  relatedDatabaseEntries
  relatedDatabaseLinks
  datasetCitations
  depositionDate
  releaseDate
  lastModifiedDate
  id
}

input DepositionCreateInput {
  depositionTitle: String!
  depositionDescription: String!
  publications: String = null
  relatedDatabaseEntries: String = null
  relatedDatabaseLinks: String = null
  datasetCitations: String = null
  depositionDate: DateTime!
  releaseDate: DateTime!
  lastModifiedDate: DateTime!
  id: Int!
}

type DepositionGroupByOptions {
  depositionTitle: String
  depositionDescription: String
  publications: String
  relatedDatabaseEntries: String
  relatedDatabaseLinks: String
  datasetCitations: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  id: Int
}

type DepositionMinMaxColumns {
  depositionTitle: String
  depositionDescription: String
  publications: String
  relatedDatabaseEntries: String
  relatedDatabaseLinks: String
  datasetCitations: String
  depositionDate: DateTime
  releaseDate: DateTime
  lastModifiedDate: DateTime
  id: Int
}

type DepositionNumericalColumns {
  id: Int
}

input DepositionOrderByClause {
  depositionTitle: orderBy
  depositionDescription: orderBy
  publications: orderBy
  relatedDatabaseEntries: orderBy
  relatedDatabaseLinks: orderBy
  datasetCitations: orderBy
  depositionDate: orderBy
  releaseDate: orderBy
  lastModifiedDate: orderBy
  id: orderBy
}

type DepositionType implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  type: deposition_types_enum
}

type DepositionTypeAggregate {
  aggregate: [DepositionTypeAggregateFunctions!]
}

type DepositionTypeAggregateFunctions {
  sum: DepositionTypeNumericalColumns
  avg: DepositionTypeNumericalColumns
  stddev: DepositionTypeNumericalColumns
  variance: DepositionTypeNumericalColumns
  min: DepositionTypeMinMaxColumns
  max: DepositionTypeMinMaxColumns
  groupBy: DepositionTypeGroupByOptions
  count(distinct: Boolean = false, columns: DepositionTypeCountColumns = null): Int
}

"""A connection to a list of items."""
type DepositionTypeConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [DepositionTypeEdge!]!
}

enum DepositionTypeCountColumns {
  deposition
  type
  id
}

input DepositionTypeCreateInput {
  depositionId: ID = null
  type: deposition_types_enum = null
  id: Int!
}

"""An edge in a connection."""
type DepositionTypeEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: DepositionType!
}

type DepositionTypeGroupByOptions {
  deposition: DepositionGroupByOptions
  type: deposition_types_enum
  id: Int
}

type DepositionTypeMinMaxColumns {
  id: Int
}

type DepositionTypeNumericalColumns {
  id: Int
}

input DepositionTypeOrderByClause {
  deposition: DepositionOrderByClause
  type: orderBy
  id: orderBy
}

input DepositionTypeUpdateInput {
  depositionId: ID = null
  type: deposition_types_enum = null
  id: Int = null
}

input DepositionTypeWhereClause {
  deposition: DepositionWhereClause
  type: Deposition_types_enumEnumComparators
  id: IntComparators
}

input DepositionTypeWhereClauseMutations {
  id: IntComparators
}

input DepositionUpdateInput {
  depositionTitle: String = null
  depositionDescription: String = null
  publications: String = null
  relatedDatabaseEntries: String = null
  relatedDatabaseLinks: String = null
  datasetCitations: String = null
  depositionDate: DateTime = null
  releaseDate: DateTime = null
  lastModifiedDate: DateTime = null
  id: Int = null
}

input DepositionWhereClause {
  authors: DepositionAuthorWhereClause
  alignments: AlignmentWhereClause
  annotations: AnnotationWhereClause
  datasets: DatasetWhereClause
  frames: FrameWhereClause
  tiltseries: TiltseriesWhereClause
  tomograms: TomogramWhereClause
  depositionTitle: StrComparators
  depositionDescription: StrComparators
  depositionTypes: DepositionTypeWhereClause
  publications: StrComparators
  relatedDatabaseEntries: StrComparators
  relatedDatabaseLinks: StrComparators
  datasetCitations: StrComparators
  depositionDate: DatetimeComparators
  releaseDate: DatetimeComparators
  lastModifiedDate: DatetimeComparators
  id: IntComparators
}

input DepositionWhereClauseMutations {
  id: IntComparators
}

input Deposition_types_enumEnumComparators {
  _eq: deposition_types_enum
  _neq: deposition_types_enum
  _in: [deposition_types_enum!]
  _nin: [deposition_types_enum!]
  _gt: deposition_types_enum
  _gte: deposition_types_enum
  _lt: deposition_types_enum
  _lte: deposition_types_enum
  _is_null: Boolean
}

interface EntityInterface implements Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

input Fiducial_alignment_status_enumEnumComparators {
  _eq: fiducial_alignment_status_enum
  _neq: fiducial_alignment_status_enum
  _in: [fiducial_alignment_status_enum!]
  _nin: [fiducial_alignment_status_enum!]
  _gt: fiducial_alignment_status_enum
  _gte: fiducial_alignment_status_enum
  _lt: fiducial_alignment_status_enum
  _lte: fiducial_alignment_status_enum
  _is_null: Boolean
}

input FloatComparators {
  _eq: Float
  _neq: Float
  _in: [Float!]
  _nin: [Float!]
  _gt: Float
  _gte: Float
  _lt: Float
  _lte: Float
  _is_null: Boolean
}

type Frame implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  perSectionParameters(
    where: PerSectionParametersWhereClause = null
    orderBy: [PerSectionParametersOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): PerSectionParametersConnection!
  perSectionParametersAggregate(where: PerSectionParametersWhereClause = null): PerSectionParametersAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  rawAngle: Float!
  acquisitionOrder: Int
  dose: Float!
  isGainCorrected: Boolean
  s3GainFile: String
  httpsGainFile: String
  s3Prefix: String!
  httpsPrefix: String!
}

type FrameAggregate {
  aggregate: [FrameAggregateFunctions!]
}

type FrameAggregateFunctions {
  sum: FrameNumericalColumns
  avg: FrameNumericalColumns
  stddev: FrameNumericalColumns
  variance: FrameNumericalColumns
  min: FrameMinMaxColumns
  max: FrameMinMaxColumns
  groupBy: FrameGroupByOptions
  count(distinct: Boolean = false, columns: FrameCountColumns = null): Int
}

"""A connection to a list of items."""
type FrameConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [FrameEdge!]!
}

enum FrameCountColumns {
  deposition
  perSectionParameters
  run
  rawAngle
  acquisitionOrder
  dose
  isGainCorrected
  s3GainFile
  httpsGainFile
  s3Prefix
  httpsPrefix
  id
}

input FrameCreateInput {
  depositionId: ID = null
  runId: ID = null
  rawAngle: Float!
  acquisitionOrder: Int = null
  dose: Float!
  isGainCorrected: Boolean = null
  s3GainFile: String = null
  httpsGainFile: String = null
  s3Prefix: String!
  httpsPrefix: String!
  id: Int!
}

"""An edge in a connection."""
type FrameEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Frame!
}

type FrameGroupByOptions {
  deposition: DepositionGroupByOptions
  run: RunGroupByOptions
  rawAngle: Float
  acquisitionOrder: Int
  dose: Float
  isGainCorrected: Boolean
  s3GainFile: String
  httpsGainFile: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type FrameMinMaxColumns {
  rawAngle: Float
  acquisitionOrder: Int
  dose: Float
  s3GainFile: String
  httpsGainFile: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type FrameNumericalColumns {
  rawAngle: Float
  acquisitionOrder: Int
  dose: Float
  id: Int
}

input FrameOrderByClause {
  deposition: DepositionOrderByClause
  run: RunOrderByClause
  rawAngle: orderBy
  acquisitionOrder: orderBy
  dose: orderBy
  isGainCorrected: orderBy
  s3GainFile: orderBy
  httpsGainFile: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

input FrameUpdateInput {
  depositionId: ID = null
  runId: ID = null
  rawAngle: Float = null
  acquisitionOrder: Int = null
  dose: Float = null
  isGainCorrected: Boolean = null
  s3GainFile: String = null
  httpsGainFile: String = null
  s3Prefix: String = null
  httpsPrefix: String = null
  id: Int = null
}

input FrameWhereClause {
  deposition: DepositionWhereClause
  perSectionParameters: PerSectionParametersWhereClause
  run: RunWhereClause
  rawAngle: FloatComparators
  acquisitionOrder: IntComparators
  dose: FloatComparators
  isGainCorrected: BoolComparators
  s3GainFile: StrComparators
  httpsGainFile: StrComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input FrameWhereClauseMutations {
  id: IntComparators
}

"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar GlobalID @specifiedBy(url: "https://relay.dev/graphql/objectidentification.htm")

input IntComparators {
  _eq: Int
  _neq: Int
  _in: [Int!]
  _nin: [Int!]
  _gt: Int
  _gte: Int
  _lt: Int
  _lte: Int
  _is_null: Boolean
}

input LimitOffsetClause {
  limit: Int
  offset: Int
}

type Mutation {
  createAlignment(input: AlignmentCreateInput!): Alignment!
  updateAlignment(input: AlignmentUpdateInput!, where: AlignmentWhereClauseMutations!): [Alignment!]!
  deleteAlignment(where: AlignmentWhereClauseMutations!): [Alignment!]!
  createAnnotationAuthor(input: AnnotationAuthorCreateInput!): AnnotationAuthor!
  updateAnnotationAuthor(input: AnnotationAuthorUpdateInput!, where: AnnotationAuthorWhereClauseMutations!): [AnnotationAuthor!]!
  deleteAnnotationAuthor(where: AnnotationAuthorWhereClauseMutations!): [AnnotationAuthor!]!
  createAnnotationFile(input: AnnotationFileCreateInput!): AnnotationFile!
  updateAnnotationFile(input: AnnotationFileUpdateInput!, where: AnnotationFileWhereClauseMutations!): [AnnotationFile!]!
  deleteAnnotationFile(where: AnnotationFileWhereClauseMutations!): [AnnotationFile!]!
  createAnnotationShape(input: AnnotationShapeCreateInput!): AnnotationShape!
  updateAnnotationShape(input: AnnotationShapeUpdateInput!, where: AnnotationShapeWhereClauseMutations!): [AnnotationShape!]!
  deleteAnnotationShape(where: AnnotationShapeWhereClauseMutations!): [AnnotationShape!]!
  createAnnotation(input: AnnotationCreateInput!): Annotation!
  updateAnnotation(input: AnnotationUpdateInput!, where: AnnotationWhereClauseMutations!): [Annotation!]!
  deleteAnnotation(where: AnnotationWhereClauseMutations!): [Annotation!]!
  createDatasetAuthor(input: DatasetAuthorCreateInput!): DatasetAuthor!
  updateDatasetAuthor(input: DatasetAuthorUpdateInput!, where: DatasetAuthorWhereClauseMutations!): [DatasetAuthor!]!
  deleteDatasetAuthor(where: DatasetAuthorWhereClauseMutations!): [DatasetAuthor!]!
  createDatasetFunding(input: DatasetFundingCreateInput!): DatasetFunding!
  updateDatasetFunding(input: DatasetFundingUpdateInput!, where: DatasetFundingWhereClauseMutations!): [DatasetFunding!]!
  deleteDatasetFunding(where: DatasetFundingWhereClauseMutations!): [DatasetFunding!]!
  createDataset(input: DatasetCreateInput!): Dataset!
  updateDataset(input: DatasetUpdateInput!, where: DatasetWhereClauseMutations!): [Dataset!]!
  deleteDataset(where: DatasetWhereClauseMutations!): [Dataset!]!
  createDepositionAuthor(input: DepositionAuthorCreateInput!): DepositionAuthor!
  updateDepositionAuthor(input: DepositionAuthorUpdateInput!, where: DepositionAuthorWhereClauseMutations!): [DepositionAuthor!]!
  deleteDepositionAuthor(where: DepositionAuthorWhereClauseMutations!): [DepositionAuthor!]!
  createDeposition(input: DepositionCreateInput!): Deposition!
  updateDeposition(input: DepositionUpdateInput!, where: DepositionWhereClauseMutations!): [Deposition!]!
  deleteDeposition(where: DepositionWhereClauseMutations!): [Deposition!]!
  createDepositionType(input: DepositionTypeCreateInput!): DepositionType!
  updateDepositionType(input: DepositionTypeUpdateInput!, where: DepositionTypeWhereClauseMutations!): [DepositionType!]!
  deleteDepositionType(where: DepositionTypeWhereClauseMutations!): [DepositionType!]!
  createFrame(input: FrameCreateInput!): Frame!
  updateFrame(input: FrameUpdateInput!, where: FrameWhereClauseMutations!): [Frame!]!
  deleteFrame(where: FrameWhereClauseMutations!): [Frame!]!
  createPerSectionParameters(input: PerSectionParametersCreateInput!): PerSectionParameters!
  updatePerSectionParameters(input: PerSectionParametersUpdateInput!, where: PerSectionParametersWhereClauseMutations!): [PerSectionParameters!]!
  deletePerSectionParameters(where: PerSectionParametersWhereClauseMutations!): [PerSectionParameters!]!
  createPerSectionAlignmentParameters(input: PerSectionAlignmentParametersCreateInput!): PerSectionAlignmentParameters!
  updatePerSectionAlignmentParameters(input: PerSectionAlignmentParametersUpdateInput!, where: PerSectionAlignmentParametersWhereClauseMutations!): [PerSectionAlignmentParameters!]!
  deletePerSectionAlignmentParameters(where: PerSectionAlignmentParametersWhereClauseMutations!): [PerSectionAlignmentParameters!]!
  createRun(input: RunCreateInput!): Run!
  updateRun(input: RunUpdateInput!, where: RunWhereClauseMutations!): [Run!]!
  deleteRun(where: RunWhereClauseMutations!): [Run!]!
  createTiltseries(input: TiltseriesCreateInput!): Tiltseries!
  updateTiltseries(input: TiltseriesUpdateInput!, where: TiltseriesWhereClauseMutations!): [Tiltseries!]!
  deleteTiltseries(where: TiltseriesWhereClauseMutations!): [Tiltseries!]!
  createTomogramAuthor(input: TomogramAuthorCreateInput!): TomogramAuthor!
  updateTomogramAuthor(input: TomogramAuthorUpdateInput!, where: TomogramAuthorWhereClauseMutations!): [TomogramAuthor!]!
  deleteTomogramAuthor(where: TomogramAuthorWhereClauseMutations!): [TomogramAuthor!]!
  createTomogramVoxelSpacing(input: TomogramVoxelSpacingCreateInput!): TomogramVoxelSpacing!
  updateTomogramVoxelSpacing(input: TomogramVoxelSpacingUpdateInput!, where: TomogramVoxelSpacingWhereClauseMutations!): [TomogramVoxelSpacing!]!
  deleteTomogramVoxelSpacing(where: TomogramVoxelSpacingWhereClauseMutations!): [TomogramVoxelSpacing!]!
  createTomogram(input: TomogramCreateInput!): Tomogram!
  updateTomogram(input: TomogramUpdateInput!, where: TomogramWhereClauseMutations!): [Tomogram!]!
  deleteTomogram(where: TomogramWhereClauseMutations!): [Tomogram!]!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type PerSectionAlignmentParameters implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  alignment(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = []): Alignment
  zIndex: Int!
  xOffset: Float
  yOffset: Float
  inPlaneRotation: Float
  beamTilt: Float
  tiltAngle: Float
}

type PerSectionAlignmentParametersAggregate {
  aggregate: [PerSectionAlignmentParametersAggregateFunctions!]
}

type PerSectionAlignmentParametersAggregateFunctions {
  sum: PerSectionAlignmentParametersNumericalColumns
  avg: PerSectionAlignmentParametersNumericalColumns
  stddev: PerSectionAlignmentParametersNumericalColumns
  variance: PerSectionAlignmentParametersNumericalColumns
  min: PerSectionAlignmentParametersMinMaxColumns
  max: PerSectionAlignmentParametersMinMaxColumns
  groupBy: PerSectionAlignmentParametersGroupByOptions
  count(distinct: Boolean = false, columns: PerSectionAlignmentParametersCountColumns = null): Int
}

"""A connection to a list of items."""
type PerSectionAlignmentParametersConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [PerSectionAlignmentParametersEdge!]!
}

enum PerSectionAlignmentParametersCountColumns {
  alignment
  zIndex
  xOffset
  yOffset
  inPlaneRotation
  beamTilt
  tiltAngle
  id
}

input PerSectionAlignmentParametersCreateInput {
  alignmentId: ID!
  zIndex: Int!
  xOffset: Float = null
  yOffset: Float = null
  inPlaneRotation: Float = null
  beamTilt: Float = null
  tiltAngle: Float = null
  id: Int!
}

"""An edge in a connection."""
type PerSectionAlignmentParametersEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: PerSectionAlignmentParameters!
}

type PerSectionAlignmentParametersGroupByOptions {
  alignment: AlignmentGroupByOptions
  zIndex: Int
  xOffset: Float
  yOffset: Float
  inPlaneRotation: Float
  beamTilt: Float
  tiltAngle: Float
  id: Int
}

type PerSectionAlignmentParametersMinMaxColumns {
  zIndex: Int
  xOffset: Float
  yOffset: Float
  inPlaneRotation: Float
  beamTilt: Float
  tiltAngle: Float
  id: Int
}

type PerSectionAlignmentParametersNumericalColumns {
  zIndex: Int
  xOffset: Float
  yOffset: Float
  inPlaneRotation: Float
  beamTilt: Float
  tiltAngle: Float
  id: Int
}

input PerSectionAlignmentParametersOrderByClause {
  alignment: AlignmentOrderByClause
  zIndex: orderBy
  xOffset: orderBy
  yOffset: orderBy
  inPlaneRotation: orderBy
  beamTilt: orderBy
  tiltAngle: orderBy
  id: orderBy
}

input PerSectionAlignmentParametersUpdateInput {
  alignmentId: ID = null
  zIndex: Int = null
  xOffset: Float = null
  yOffset: Float = null
  inPlaneRotation: Float = null
  beamTilt: Float = null
  tiltAngle: Float = null
  id: Int = null
}

input PerSectionAlignmentParametersWhereClause {
  alignment: AlignmentWhereClause
  zIndex: IntComparators
  xOffset: FloatComparators
  yOffset: FloatComparators
  inPlaneRotation: FloatComparators
  beamTilt: FloatComparators
  tiltAngle: FloatComparators
  id: IntComparators
}

input PerSectionAlignmentParametersWhereClauseMutations {
  id: IntComparators
}

type PerSectionParameters implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  frame(where: FrameWhereClause = null, orderBy: [FrameOrderByClause!] = []): Frame
  tiltseries(where: TiltseriesWhereClause = null, orderBy: [TiltseriesOrderByClause!] = []): Tiltseries
  zIndex: Int!
  defocus: Float
  astigmatism: Float
  astigmaticAngle: Float
}

type PerSectionParametersAggregate {
  aggregate: [PerSectionParametersAggregateFunctions!]
}

type PerSectionParametersAggregateFunctions {
  sum: PerSectionParametersNumericalColumns
  avg: PerSectionParametersNumericalColumns
  stddev: PerSectionParametersNumericalColumns
  variance: PerSectionParametersNumericalColumns
  min: PerSectionParametersMinMaxColumns
  max: PerSectionParametersMinMaxColumns
  groupBy: PerSectionParametersGroupByOptions
  count(distinct: Boolean = false, columns: PerSectionParametersCountColumns = null): Int
}

"""A connection to a list of items."""
type PerSectionParametersConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [PerSectionParametersEdge!]!
}

enum PerSectionParametersCountColumns {
  frame
  tiltseries
  zIndex
  defocus
  astigmatism
  astigmaticAngle
  id
}

input PerSectionParametersCreateInput {
  frameId: ID!
  tiltseriesId: ID!
  zIndex: Int!
  defocus: Float = null
  astigmatism: Float = null
  astigmaticAngle: Float = null
  id: Int!
}

"""An edge in a connection."""
type PerSectionParametersEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: PerSectionParameters!
}

type PerSectionParametersGroupByOptions {
  frame: FrameGroupByOptions
  tiltseries: TiltseriesGroupByOptions
  zIndex: Int
  defocus: Float
  astigmatism: Float
  astigmaticAngle: Float
  id: Int
}

type PerSectionParametersMinMaxColumns {
  zIndex: Int
  defocus: Float
  astigmatism: Float
  astigmaticAngle: Float
  id: Int
}

type PerSectionParametersNumericalColumns {
  zIndex: Int
  defocus: Float
  astigmatism: Float
  astigmaticAngle: Float
  id: Int
}

input PerSectionParametersOrderByClause {
  frame: FrameOrderByClause
  tiltseries: TiltseriesOrderByClause
  zIndex: orderBy
  defocus: orderBy
  astigmatism: orderBy
  astigmaticAngle: orderBy
  id: orderBy
}

input PerSectionParametersUpdateInput {
  frameId: ID = null
  tiltseriesId: ID = null
  zIndex: Int = null
  defocus: Float = null
  astigmatism: Float = null
  astigmaticAngle: Float = null
  id: Int = null
}

input PerSectionParametersWhereClause {
  frame: FrameWhereClause
  tiltseries: TiltseriesWhereClause
  zIndex: IntComparators
  defocus: FloatComparators
  astigmatism: FloatComparators
  astigmaticAngle: FloatComparators
  id: IntComparators
}

input PerSectionParametersWhereClauseMutations {
  id: IntComparators
}

type Query {
  node(
    """The ID of the object."""
    id: GlobalID!
  ): Node!
  nodes(
    """The IDs of the objects."""
    ids: [GlobalID!]!
  ): [Node!]!
  alignments(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Alignment!]!
  annotationAuthors(where: AnnotationAuthorWhereClause = null, orderBy: [AnnotationAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationAuthor!]!
  annotationFiles(where: AnnotationFileWhereClause = null, orderBy: [AnnotationFileOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationFile!]!
  annotationShapes(where: AnnotationShapeWhereClause = null, orderBy: [AnnotationShapeOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [AnnotationShape!]!
  annotations(where: AnnotationWhereClause = null, orderBy: [AnnotationOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Annotation!]!
  datasetAuthors(where: DatasetAuthorWhereClause = null, orderBy: [DatasetAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DatasetAuthor!]!
  datasetFunding(where: DatasetFundingWhereClause = null, orderBy: [DatasetFundingOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DatasetFunding!]!
  datasets(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Dataset!]!
  depositionAuthors(where: DepositionAuthorWhereClause = null, orderBy: [DepositionAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DepositionAuthor!]!
  depositions(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Deposition!]!
  depositionTypes(where: DepositionTypeWhereClause = null, orderBy: [DepositionTypeOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [DepositionType!]!
  frames(where: FrameWhereClause = null, orderBy: [FrameOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Frame!]!
  perSectionParameters(where: PerSectionParametersWhereClause = null, orderBy: [PerSectionParametersOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [PerSectionParameters!]!
  perSectionAlignmentParameters(where: PerSectionAlignmentParametersWhereClause = null, orderBy: [PerSectionAlignmentParametersOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [PerSectionAlignmentParameters!]!
  runs(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Run!]!
  tiltseries(where: TiltseriesWhereClause = null, orderBy: [TiltseriesOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Tiltseries!]!
  tomogramAuthors(where: TomogramAuthorWhereClause = null, orderBy: [TomogramAuthorOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [TomogramAuthor!]!
  tomogramVoxelSpacings(where: TomogramVoxelSpacingWhereClause = null, orderBy: [TomogramVoxelSpacingOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [TomogramVoxelSpacing!]!
  tomograms(where: TomogramWhereClause = null, orderBy: [TomogramOrderByClause!] = [], limitOffset: LimitOffsetClause = null): [Tomogram!]!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate!
  annotationAuthorsAggregate(where: AnnotationAuthorWhereClause = null): AnnotationAuthorAggregate!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate!
  annotationShapesAggregate(where: AnnotationShapeWhereClause = null): AnnotationShapeAggregate!
  annotationsAggregate(where: AnnotationWhereClause = null): AnnotationAggregate!
  datasetAuthorsAggregate(where: DatasetAuthorWhereClause = null): DatasetAuthorAggregate!
  datasetFundingAggregate(where: DatasetFundingWhereClause = null): DatasetFundingAggregate!
  datasetsAggregate(where: DatasetWhereClause = null): DatasetAggregate!
  depositionAuthorsAggregate(where: DepositionAuthorWhereClause = null): DepositionAuthorAggregate!
  depositionsAggregate(where: DepositionWhereClause = null): DepositionAggregate!
  depositionTypesAggregate(where: DepositionTypeWhereClause = null): DepositionTypeAggregate!
  framesAggregate(where: FrameWhereClause = null): FrameAggregate!
  perSectionParametersAggregate(where: PerSectionParametersWhereClause = null): PerSectionParametersAggregate!
  perSectionAlignmentParametersAggregate(where: PerSectionAlignmentParametersWhereClause = null): PerSectionAlignmentParametersAggregate!
  runsAggregate(where: RunWhereClause = null): RunAggregate!
  tiltseriesAggregate(where: TiltseriesWhereClause = null): TiltseriesAggregate!
  tomogramAuthorsAggregate(where: TomogramAuthorWhereClause = null): TomogramAuthorAggregate!
  tomogramVoxelSpacingsAggregate(where: TomogramVoxelSpacingWhereClause = null): TomogramVoxelSpacingAggregate!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate!
}

type Run implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  alignments(
    where: AlignmentWhereClause = null
    orderBy: [AlignmentOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AlignmentConnection!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate
  annotations(
    where: AnnotationWhereClause = null
    orderBy: [AnnotationOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationConnection!
  annotationsAggregate(where: AnnotationWhereClause = null): AnnotationAggregate
  dataset(where: DatasetWhereClause = null, orderBy: [DatasetOrderByClause!] = []): Dataset
  frames(
    where: FrameWhereClause = null
    orderBy: [FrameOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): FrameConnection!
  framesAggregate(where: FrameWhereClause = null): FrameAggregate
  tiltseries(
    where: TiltseriesWhereClause = null
    orderBy: [TiltseriesOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TiltseriesConnection!
  tiltseriesAggregate(where: TiltseriesWhereClause = null): TiltseriesAggregate
  tomogramVoxelSpacings(
    where: TomogramVoxelSpacingWhereClause = null
    orderBy: [TomogramVoxelSpacingOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramVoxelSpacingConnection!
  tomogramVoxelSpacingsAggregate(where: TomogramVoxelSpacingWhereClause = null): TomogramVoxelSpacingAggregate
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate
  name: String!
  s3Prefix: String!
  httpsPrefix: String!
}

type RunAggregate {
  aggregate: [RunAggregateFunctions!]
}

type RunAggregateFunctions {
  sum: RunNumericalColumns
  avg: RunNumericalColumns
  stddev: RunNumericalColumns
  variance: RunNumericalColumns
  min: RunMinMaxColumns
  max: RunMinMaxColumns
  groupBy: RunGroupByOptions
  count(distinct: Boolean = false, columns: RunCountColumns = null): Int
}

"""A connection to a list of items."""
type RunConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [RunEdge!]!
}

enum RunCountColumns {
  alignments
  annotations
  dataset
  frames
  tiltseries
  tomogramVoxelSpacings
  tomograms
  name
  s3Prefix
  httpsPrefix
  id
}

input RunCreateInput {
  datasetId: ID!
  name: String!
  s3Prefix: String!
  httpsPrefix: String!
  id: Int!
}

"""An edge in a connection."""
type RunEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Run!
}

type RunGroupByOptions {
  dataset: DatasetGroupByOptions
  name: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type RunMinMaxColumns {
  name: String
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type RunNumericalColumns {
  id: Int
}

input RunOrderByClause {
  dataset: DatasetOrderByClause
  name: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

input RunUpdateInput {
  datasetId: ID = null
  name: String = null
  s3Prefix: String = null
  httpsPrefix: String = null
  id: Int = null
}

input RunWhereClause {
  alignments: AlignmentWhereClause
  annotations: AnnotationWhereClause
  dataset: DatasetWhereClause
  frames: FrameWhereClause
  tiltseries: TiltseriesWhereClause
  tomogramVoxelSpacings: TomogramVoxelSpacingWhereClause
  tomograms: TomogramWhereClause
  name: StrComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input RunWhereClauseMutations {
  id: IntComparators
}

input Sample_type_enumEnumComparators {
  _eq: sample_type_enum
  _neq: sample_type_enum
  _in: [sample_type_enum!]
  _nin: [sample_type_enum!]
  _gt: sample_type_enum
  _gte: sample_type_enum
  _lt: sample_type_enum
  _lte: sample_type_enum
  _is_null: Boolean
}

input StrComparators {
  _eq: String
  _neq: String
  _in: [String!]
  _nin: [String!]
  _is_null: Boolean
  _gt: String
  _gte: String
  _lt: String
  _lte: String
  _like: String
  _nlike: String
  _ilike: String
  _nilike: String
  _regex: String
  _nregex: String
  _iregex: String
  _niregex: String
}

type Tiltseries implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  alignments(
    where: AlignmentWhereClause = null
    orderBy: [AlignmentOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AlignmentConnection!
  alignmentsAggregate(where: AlignmentWhereClause = null): AlignmentAggregate
  perSectionParameters(
    where: PerSectionParametersWhereClause = null
    orderBy: [PerSectionParametersOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): PerSectionParametersConnection!
  perSectionParametersAggregate(where: PerSectionParametersWhereClause = null): PerSectionParametersAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  s3OmezarrDir: String
  s3MrcBin1: String
  httpsOmezarrDir: String
  httpsMrcBin1: String
  s3CollectionMetadata: String
  httpsCollectionMetadata: String
  s3AngleList: String
  httpsAngleList: String
  s3GainFile: String
  httpsGainFile: String
  accelerationVoltage: Float!
  sphericalAberrationConstant: Float!
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum!
  microscopeModel: String!
  microscopeEnergyFilter: String!
  microscopePhasePlate: String
  microscopeImageCorrector: String
  microscopeAdditionalInfo: String
  cameraManufacturer: String!
  cameraModel: String!
  tiltMin: Float!
  tiltMax: Float!
  tiltRange: Float!
  tiltStep: Float!
  tiltingScheme: String!
  tiltAxis: Float!
  totalFlux: Float!
  dataAcquisitionSoftware: String!
  relatedEmpiarEntry: String
  binningFromFrames: Float
  tiltSeriesQuality: Int!
  isAligned: Boolean!
  pixelSpacing: Float!
  alignedTiltseriesBinning: Float
  tiltseriesFramesCount: Int
}

type TiltseriesAggregate {
  aggregate: [TiltseriesAggregateFunctions!]
}

type TiltseriesAggregateFunctions {
  sum: TiltseriesNumericalColumns
  avg: TiltseriesNumericalColumns
  stddev: TiltseriesNumericalColumns
  variance: TiltseriesNumericalColumns
  min: TiltseriesMinMaxColumns
  max: TiltseriesMinMaxColumns
  groupBy: TiltseriesGroupByOptions
  count(distinct: Boolean = false, columns: TiltseriesCountColumns = null): Int
}

"""A connection to a list of items."""
type TiltseriesConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TiltseriesEdge!]!
}

enum TiltseriesCountColumns {
  alignments
  perSectionParameters
  run
  deposition
  s3OmezarrDir
  s3MrcBin1
  httpsOmezarrDir
  httpsMrcBin1
  s3CollectionMetadata
  httpsCollectionMetadata
  s3AngleList
  httpsAngleList
  s3GainFile
  httpsGainFile
  accelerationVoltage
  sphericalAberrationConstant
  microscopeManufacturer
  microscopeModel
  microscopeEnergyFilter
  microscopePhasePlate
  microscopeImageCorrector
  microscopeAdditionalInfo
  cameraManufacturer
  cameraModel
  tiltMin
  tiltMax
  tiltRange
  tiltStep
  tiltingScheme
  tiltAxis
  totalFlux
  dataAcquisitionSoftware
  relatedEmpiarEntry
  binningFromFrames
  tiltSeriesQuality
  isAligned
  pixelSpacing
  alignedTiltseriesBinning
  tiltseriesFramesCount
  id
}

input TiltseriesCreateInput {
  runId: ID!
  depositionId: ID = null
  s3OmezarrDir: String = null
  s3MrcBin1: String = null
  httpsOmezarrDir: String = null
  httpsMrcBin1: String = null
  s3CollectionMetadata: String = null
  httpsCollectionMetadata: String = null
  s3AngleList: String = null
  httpsAngleList: String = null
  s3GainFile: String = null
  httpsGainFile: String = null
  accelerationVoltage: Float!
  sphericalAberrationConstant: Float!
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum!
  microscopeModel: String!
  microscopeEnergyFilter: String!
  microscopePhasePlate: String = null
  microscopeImageCorrector: String = null
  microscopeAdditionalInfo: String = null
  cameraManufacturer: String!
  cameraModel: String!
  tiltMin: Float!
  tiltMax: Float!
  tiltRange: Float!
  tiltStep: Float!
  tiltingScheme: String!
  tiltAxis: Float!
  totalFlux: Float!
  dataAcquisitionSoftware: String!
  relatedEmpiarEntry: String = null
  binningFromFrames: Float = null
  tiltSeriesQuality: Int!
  isAligned: Boolean!
  pixelSpacing: Float!
  alignedTiltseriesBinning: Float = null
  tiltseriesFramesCount: Int = null
  id: Int!
}

"""An edge in a connection."""
type TiltseriesEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Tiltseries!
}

type TiltseriesGroupByOptions {
  run: RunGroupByOptions
  deposition: DepositionGroupByOptions
  s3OmezarrDir: String
  s3MrcBin1: String
  httpsOmezarrDir: String
  httpsMrcBin1: String
  s3CollectionMetadata: String
  httpsCollectionMetadata: String
  s3AngleList: String
  httpsAngleList: String
  s3GainFile: String
  httpsGainFile: String
  accelerationVoltage: Float
  sphericalAberrationConstant: Float
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum
  microscopeModel: String
  microscopeEnergyFilter: String
  microscopePhasePlate: String
  microscopeImageCorrector: String
  microscopeAdditionalInfo: String
  cameraManufacturer: String
  cameraModel: String
  tiltMin: Float
  tiltMax: Float
  tiltRange: Float
  tiltStep: Float
  tiltingScheme: String
  tiltAxis: Float
  totalFlux: Float
  dataAcquisitionSoftware: String
  relatedEmpiarEntry: String
  binningFromFrames: Float
  tiltSeriesQuality: Int
  isAligned: Boolean
  pixelSpacing: Float
  alignedTiltseriesBinning: Float
  tiltseriesFramesCount: Int
  id: Int
}

type TiltseriesMinMaxColumns {
  s3OmezarrDir: String
  s3MrcBin1: String
  httpsOmezarrDir: String
  httpsMrcBin1: String
  s3CollectionMetadata: String
  httpsCollectionMetadata: String
  s3AngleList: String
  httpsAngleList: String
  s3GainFile: String
  httpsGainFile: String
  accelerationVoltage: Float
  sphericalAberrationConstant: Float
  microscopeModel: String
  microscopeEnergyFilter: String
  microscopePhasePlate: String
  microscopeImageCorrector: String
  microscopeAdditionalInfo: String
  cameraManufacturer: String
  cameraModel: String
  tiltMin: Float
  tiltMax: Float
  tiltRange: Float
  tiltStep: Float
  tiltingScheme: String
  tiltAxis: Float
  totalFlux: Float
  dataAcquisitionSoftware: String
  relatedEmpiarEntry: String
  binningFromFrames: Float
  tiltSeriesQuality: Int
  pixelSpacing: Float
  alignedTiltseriesBinning: Float
  tiltseriesFramesCount: Int
  id: Int
}

type TiltseriesNumericalColumns {
  accelerationVoltage: Float
  sphericalAberrationConstant: Float
  tiltMin: Float
  tiltMax: Float
  tiltRange: Float
  tiltStep: Float
  tiltAxis: Float
  totalFlux: Float
  binningFromFrames: Float
  tiltSeriesQuality: Int
  pixelSpacing: Float
  alignedTiltseriesBinning: Float
  tiltseriesFramesCount: Int
  id: Int
}

input TiltseriesOrderByClause {
  run: RunOrderByClause
  deposition: DepositionOrderByClause
  s3OmezarrDir: orderBy
  s3MrcBin1: orderBy
  httpsOmezarrDir: orderBy
  httpsMrcBin1: orderBy
  s3CollectionMetadata: orderBy
  httpsCollectionMetadata: orderBy
  s3AngleList: orderBy
  httpsAngleList: orderBy
  s3GainFile: orderBy
  httpsGainFile: orderBy
  accelerationVoltage: orderBy
  sphericalAberrationConstant: orderBy
  microscopeManufacturer: orderBy
  microscopeModel: orderBy
  microscopeEnergyFilter: orderBy
  microscopePhasePlate: orderBy
  microscopeImageCorrector: orderBy
  microscopeAdditionalInfo: orderBy
  cameraManufacturer: orderBy
  cameraModel: orderBy
  tiltMin: orderBy
  tiltMax: orderBy
  tiltRange: orderBy
  tiltStep: orderBy
  tiltingScheme: orderBy
  tiltAxis: orderBy
  totalFlux: orderBy
  dataAcquisitionSoftware: orderBy
  relatedEmpiarEntry: orderBy
  binningFromFrames: orderBy
  tiltSeriesQuality: orderBy
  isAligned: orderBy
  pixelSpacing: orderBy
  alignedTiltseriesBinning: orderBy
  tiltseriesFramesCount: orderBy
  id: orderBy
}

input TiltseriesUpdateInput {
  runId: ID = null
  depositionId: ID = null
  s3OmezarrDir: String = null
  s3MrcBin1: String = null
  httpsOmezarrDir: String = null
  httpsMrcBin1: String = null
  s3CollectionMetadata: String = null
  httpsCollectionMetadata: String = null
  s3AngleList: String = null
  httpsAngleList: String = null
  s3GainFile: String = null
  httpsGainFile: String = null
  accelerationVoltage: Float = null
  sphericalAberrationConstant: Float = null
  microscopeManufacturer: tiltseries_microscope_manufacturer_enum = null
  microscopeModel: String = null
  microscopeEnergyFilter: String = null
  microscopePhasePlate: String = null
  microscopeImageCorrector: String = null
  microscopeAdditionalInfo: String = null
  cameraManufacturer: String = null
  cameraModel: String = null
  tiltMin: Float = null
  tiltMax: Float = null
  tiltRange: Float = null
  tiltStep: Float = null
  tiltingScheme: String = null
  tiltAxis: Float = null
  totalFlux: Float = null
  dataAcquisitionSoftware: String = null
  relatedEmpiarEntry: String = null
  binningFromFrames: Float = null
  tiltSeriesQuality: Int = null
  isAligned: Boolean = null
  pixelSpacing: Float = null
  alignedTiltseriesBinning: Float = null
  tiltseriesFramesCount: Int = null
  id: Int = null
}

input TiltseriesWhereClause {
  alignments: AlignmentWhereClause
  perSectionParameters: PerSectionParametersWhereClause
  run: RunWhereClause
  deposition: DepositionWhereClause
  s3OmezarrDir: StrComparators
  s3MrcBin1: StrComparators
  httpsOmezarrDir: StrComparators
  httpsMrcBin1: StrComparators
  s3CollectionMetadata: StrComparators
  httpsCollectionMetadata: StrComparators
  s3AngleList: StrComparators
  httpsAngleList: StrComparators
  s3GainFile: StrComparators
  httpsGainFile: StrComparators
  accelerationVoltage: FloatComparators
  sphericalAberrationConstant: FloatComparators
  microscopeManufacturer: Tiltseries_microscope_manufacturer_enumEnumComparators
  microscopeModel: StrComparators
  microscopeEnergyFilter: StrComparators
  microscopePhasePlate: StrComparators
  microscopeImageCorrector: StrComparators
  microscopeAdditionalInfo: StrComparators
  cameraManufacturer: StrComparators
  cameraModel: StrComparators
  tiltMin: FloatComparators
  tiltMax: FloatComparators
  tiltRange: FloatComparators
  tiltStep: FloatComparators
  tiltingScheme: StrComparators
  tiltAxis: FloatComparators
  totalFlux: FloatComparators
  dataAcquisitionSoftware: StrComparators
  relatedEmpiarEntry: StrComparators
  binningFromFrames: FloatComparators
  tiltSeriesQuality: IntComparators
  isAligned: BoolComparators
  pixelSpacing: FloatComparators
  alignedTiltseriesBinning: FloatComparators
  tiltseriesFramesCount: IntComparators
  id: IntComparators
}

input TiltseriesWhereClauseMutations {
  id: IntComparators
}

input Tiltseries_microscope_manufacturer_enumEnumComparators {
  _eq: tiltseries_microscope_manufacturer_enum
  _neq: tiltseries_microscope_manufacturer_enum
  _in: [tiltseries_microscope_manufacturer_enum!]
  _nin: [tiltseries_microscope_manufacturer_enum!]
  _gt: tiltseries_microscope_manufacturer_enum
  _gte: tiltseries_microscope_manufacturer_enum
  _lt: tiltseries_microscope_manufacturer_enum
  _lte: tiltseries_microscope_manufacturer_enum
  _is_null: Boolean
}

type Tomogram implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  alignment(where: AlignmentWhereClause = null, orderBy: [AlignmentOrderByClause!] = []): Alignment
  authors(
    where: TomogramAuthorWhereClause = null
    orderBy: [TomogramAuthorOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramAuthorConnection!
  authorsAggregate(where: TomogramAuthorWhereClause = null): TomogramAuthorAggregate
  deposition(where: DepositionWhereClause = null, orderBy: [DepositionOrderByClause!] = []): Deposition
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  tomogramVoxelSpacing(where: TomogramVoxelSpacingWhereClause = null, orderBy: [TomogramVoxelSpacingOrderByClause!] = []): TomogramVoxelSpacing
  name: String
  sizeX: Float!
  sizeY: Float!
  sizeZ: Float!
  voxelSpacing: Float!
  fiducialAlignmentStatus: fiducial_alignment_status_enum!
  reconstructionMethod: tomogram_reconstruction_method_enum!
  processing: tomogram_processing_enum!
  tomogramVersion: Float
  processingSoftware: String
  reconstructionSoftware: String!
  isCanonical: Boolean
  s3OmezarrDir: String
  httpsOmezarrDir: String
  s3MrcScale0: String
  httpsMrcScale0: String
  scale0Dimensions: String
  scale1Dimensions: String
  scale2Dimensions: String
  ctfCorrected: Boolean
  offsetX: Int!
  offsetY: Int!
  offsetZ: Int!
  affineTransformationMatrix: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  neuroglancerConfig: String
  tomogramType: tomogram_type_enum
  isStandardized: Boolean!
}

type TomogramAggregate {
  aggregate: [TomogramAggregateFunctions!]
}

type TomogramAggregateFunctions {
  sum: TomogramNumericalColumns
  avg: TomogramNumericalColumns
  stddev: TomogramNumericalColumns
  variance: TomogramNumericalColumns
  min: TomogramMinMaxColumns
  max: TomogramMinMaxColumns
  groupBy: TomogramGroupByOptions
  count(distinct: Boolean = false, columns: TomogramCountColumns = null): Int
}

type TomogramAuthor implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  tomogram(where: TomogramWhereClause = null, orderBy: [TomogramOrderByClause!] = []): Tomogram
  authorListOrder: Int!
  orcid: String
  name: String!
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
}

type TomogramAuthorAggregate {
  aggregate: [TomogramAuthorAggregateFunctions!]
}

type TomogramAuthorAggregateFunctions {
  sum: TomogramAuthorNumericalColumns
  avg: TomogramAuthorNumericalColumns
  stddev: TomogramAuthorNumericalColumns
  variance: TomogramAuthorNumericalColumns
  min: TomogramAuthorMinMaxColumns
  max: TomogramAuthorMinMaxColumns
  groupBy: TomogramAuthorGroupByOptions
  count(distinct: Boolean = false, columns: TomogramAuthorCountColumns = null): Int
}

"""A connection to a list of items."""
type TomogramAuthorConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TomogramAuthorEdge!]!
}

enum TomogramAuthorCountColumns {
  tomogram
  authorListOrder
  orcid
  name
  email
  affiliationName
  affiliationAddress
  affiliationIdentifier
  correspondingAuthorStatus
  primaryAuthorStatus
  id
}

input TomogramAuthorCreateInput {
  tomogramId: ID = null
  authorListOrder: Int!
  orcid: String = null
  name: String!
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  id: Int!
}

"""An edge in a connection."""
type TomogramAuthorEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: TomogramAuthor!
}

type TomogramAuthorGroupByOptions {
  tomogram: TomogramGroupByOptions
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  correspondingAuthorStatus: Boolean
  primaryAuthorStatus: Boolean
  id: Int
}

type TomogramAuthorMinMaxColumns {
  authorListOrder: Int
  orcid: String
  name: String
  email: String
  affiliationName: String
  affiliationAddress: String
  affiliationIdentifier: String
  id: Int
}

type TomogramAuthorNumericalColumns {
  authorListOrder: Int
  id: Int
}

input TomogramAuthorOrderByClause {
  tomogram: TomogramOrderByClause
  authorListOrder: orderBy
  orcid: orderBy
  name: orderBy
  email: orderBy
  affiliationName: orderBy
  affiliationAddress: orderBy
  affiliationIdentifier: orderBy
  correspondingAuthorStatus: orderBy
  primaryAuthorStatus: orderBy
  id: orderBy
}

input TomogramAuthorUpdateInput {
  tomogramId: ID = null
  authorListOrder: Int = null
  orcid: String = null
  name: String = null
  email: String = null
  affiliationName: String = null
  affiliationAddress: String = null
  affiliationIdentifier: String = null
  correspondingAuthorStatus: Boolean = null
  primaryAuthorStatus: Boolean = null
  id: Int = null
}

input TomogramAuthorWhereClause {
  tomogram: TomogramWhereClause
  authorListOrder: IntComparators
  orcid: StrComparators
  name: StrComparators
  email: StrComparators
  affiliationName: StrComparators
  affiliationAddress: StrComparators
  affiliationIdentifier: StrComparators
  correspondingAuthorStatus: BoolComparators
  primaryAuthorStatus: BoolComparators
  id: IntComparators
}

input TomogramAuthorWhereClauseMutations {
  id: IntComparators
}

"""A connection to a list of items."""
type TomogramConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TomogramEdge!]!
}

enum TomogramCountColumns {
  alignment
  authors
  deposition
  run
  tomogramVoxelSpacing
  name
  sizeX
  sizeY
  sizeZ
  voxelSpacing
  fiducialAlignmentStatus
  reconstructionMethod
  processing
  tomogramVersion
  processingSoftware
  reconstructionSoftware
  isCanonical
  s3OmezarrDir
  httpsOmezarrDir
  s3MrcScale0
  httpsMrcScale0
  scale0Dimensions
  scale1Dimensions
  scale2Dimensions
  ctfCorrected
  offsetX
  offsetY
  offsetZ
  affineTransformationMatrix
  keyPhotoUrl
  keyPhotoThumbnailUrl
  neuroglancerConfig
  tomogramType
  isStandardized
  id
}

input TomogramCreateInput {
  alignmentId: ID = null
  depositionId: ID = null
  runId: ID = null
  tomogramVoxelSpacingId: ID = null
  name: String = null
  sizeX: Float!
  sizeY: Float!
  sizeZ: Float!
  voxelSpacing: Float!
  fiducialAlignmentStatus: fiducial_alignment_status_enum!
  reconstructionMethod: tomogram_reconstruction_method_enum!
  processing: tomogram_processing_enum!
  tomogramVersion: Float = null
  processingSoftware: String = null
  reconstructionSoftware: String!
  isCanonical: Boolean = null
  s3OmezarrDir: String = null
  httpsOmezarrDir: String = null
  s3MrcScale0: String = null
  httpsMrcScale0: String = null
  scale0Dimensions: String = null
  scale1Dimensions: String = null
  scale2Dimensions: String = null
  ctfCorrected: Boolean = null
  offsetX: Int!
  offsetY: Int!
  offsetZ: Int!
  affineTransformationMatrix: String = null
  keyPhotoUrl: String = null
  keyPhotoThumbnailUrl: String = null
  neuroglancerConfig: String = null
  tomogramType: tomogram_type_enum = null
  isStandardized: Boolean!
  id: Int!
}

"""An edge in a connection."""
type TomogramEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Tomogram!
}

type TomogramGroupByOptions {
  alignment: AlignmentGroupByOptions
  deposition: DepositionGroupByOptions
  run: RunGroupByOptions
  tomogramVoxelSpacing: TomogramVoxelSpacingGroupByOptions
  name: String
  sizeX: Float
  sizeY: Float
  sizeZ: Float
  voxelSpacing: Float
  fiducialAlignmentStatus: fiducial_alignment_status_enum
  reconstructionMethod: tomogram_reconstruction_method_enum
  processing: tomogram_processing_enum
  tomogramVersion: Float
  processingSoftware: String
  reconstructionSoftware: String
  isCanonical: Boolean
  s3OmezarrDir: String
  httpsOmezarrDir: String
  s3MrcScale0: String
  httpsMrcScale0: String
  scale0Dimensions: String
  scale1Dimensions: String
  scale2Dimensions: String
  ctfCorrected: Boolean
  offsetX: Int
  offsetY: Int
  offsetZ: Int
  affineTransformationMatrix: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  neuroglancerConfig: String
  tomogramType: tomogram_type_enum
  isStandardized: Boolean
  id: Int
}

type TomogramMinMaxColumns {
  name: String
  sizeX: Float
  sizeY: Float
  sizeZ: Float
  voxelSpacing: Float
  tomogramVersion: Float
  processingSoftware: String
  reconstructionSoftware: String
  s3OmezarrDir: String
  httpsOmezarrDir: String
  s3MrcScale0: String
  httpsMrcScale0: String
  scale0Dimensions: String
  scale1Dimensions: String
  scale2Dimensions: String
  offsetX: Int
  offsetY: Int
  offsetZ: Int
  affineTransformationMatrix: String
  keyPhotoUrl: String
  keyPhotoThumbnailUrl: String
  neuroglancerConfig: String
  id: Int
}

type TomogramNumericalColumns {
  sizeX: Float
  sizeY: Float
  sizeZ: Float
  voxelSpacing: Float
  tomogramVersion: Float
  offsetX: Int
  offsetY: Int
  offsetZ: Int
  id: Int
}

input TomogramOrderByClause {
  alignment: AlignmentOrderByClause
  deposition: DepositionOrderByClause
  run: RunOrderByClause
  tomogramVoxelSpacing: TomogramVoxelSpacingOrderByClause
  name: orderBy
  sizeX: orderBy
  sizeY: orderBy
  sizeZ: orderBy
  voxelSpacing: orderBy
  fiducialAlignmentStatus: orderBy
  reconstructionMethod: orderBy
  processing: orderBy
  tomogramVersion: orderBy
  processingSoftware: orderBy
  reconstructionSoftware: orderBy
  isCanonical: orderBy
  s3OmezarrDir: orderBy
  httpsOmezarrDir: orderBy
  s3MrcScale0: orderBy
  httpsMrcScale0: orderBy
  scale0Dimensions: orderBy
  scale1Dimensions: orderBy
  scale2Dimensions: orderBy
  ctfCorrected: orderBy
  offsetX: orderBy
  offsetY: orderBy
  offsetZ: orderBy
  affineTransformationMatrix: orderBy
  keyPhotoUrl: orderBy
  keyPhotoThumbnailUrl: orderBy
  neuroglancerConfig: orderBy
  tomogramType: orderBy
  isStandardized: orderBy
  id: orderBy
}

input TomogramUpdateInput {
  alignmentId: ID = null
  depositionId: ID = null
  runId: ID = null
  tomogramVoxelSpacingId: ID = null
  name: String = null
  sizeX: Float = null
  sizeY: Float = null
  sizeZ: Float = null
  voxelSpacing: Float = null
  fiducialAlignmentStatus: fiducial_alignment_status_enum = null
  reconstructionMethod: tomogram_reconstruction_method_enum = null
  processing: tomogram_processing_enum = null
  tomogramVersion: Float = null
  processingSoftware: String = null
  reconstructionSoftware: String = null
  isCanonical: Boolean = null
  s3OmezarrDir: String = null
  httpsOmezarrDir: String = null
  s3MrcScale0: String = null
  httpsMrcScale0: String = null
  scale0Dimensions: String = null
  scale1Dimensions: String = null
  scale2Dimensions: String = null
  ctfCorrected: Boolean = null
  offsetX: Int = null
  offsetY: Int = null
  offsetZ: Int = null
  affineTransformationMatrix: String = null
  keyPhotoUrl: String = null
  keyPhotoThumbnailUrl: String = null
  neuroglancerConfig: String = null
  tomogramType: tomogram_type_enum = null
  isStandardized: Boolean = null
  id: Int = null
}

type TomogramVoxelSpacing implements EntityInterface & Node {
  """The Globally Unique ID of this object"""
  _id: GlobalID!
  id: Int!
  annotationFiles(
    where: AnnotationFileWhereClause = null
    orderBy: [AnnotationFileOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): AnnotationFileConnection!
  annotationFilesAggregate(where: AnnotationFileWhereClause = null): AnnotationFileAggregate
  run(where: RunWhereClause = null, orderBy: [RunOrderByClause!] = []): Run
  tomograms(
    where: TomogramWhereClause = null
    orderBy: [TomogramOrderByClause!] = []

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): TomogramConnection!
  tomogramsAggregate(where: TomogramWhereClause = null): TomogramAggregate
  voxelSpacing: Float!
  s3Prefix: String!
  httpsPrefix: String!
}

type TomogramVoxelSpacingAggregate {
  aggregate: [TomogramVoxelSpacingAggregateFunctions!]
}

type TomogramVoxelSpacingAggregateFunctions {
  sum: TomogramVoxelSpacingNumericalColumns
  avg: TomogramVoxelSpacingNumericalColumns
  stddev: TomogramVoxelSpacingNumericalColumns
  variance: TomogramVoxelSpacingNumericalColumns
  min: TomogramVoxelSpacingMinMaxColumns
  max: TomogramVoxelSpacingMinMaxColumns
  groupBy: TomogramVoxelSpacingGroupByOptions
  count(distinct: Boolean = false, columns: TomogramVoxelSpacingCountColumns = null): Int
}

"""A connection to a list of items."""
type TomogramVoxelSpacingConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [TomogramVoxelSpacingEdge!]!
}

enum TomogramVoxelSpacingCountColumns {
  annotationFiles
  run
  tomograms
  voxelSpacing
  s3Prefix
  httpsPrefix
  id
}

input TomogramVoxelSpacingCreateInput {
  runId: ID = null
  voxelSpacing: Float!
  s3Prefix: String!
  httpsPrefix: String!
  id: Int!
}

"""An edge in a connection."""
type TomogramVoxelSpacingEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: TomogramVoxelSpacing!
}

type TomogramVoxelSpacingGroupByOptions {
  run: RunGroupByOptions
  voxelSpacing: Float
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type TomogramVoxelSpacingMinMaxColumns {
  voxelSpacing: Float
  s3Prefix: String
  httpsPrefix: String
  id: Int
}

type TomogramVoxelSpacingNumericalColumns {
  voxelSpacing: Float
  id: Int
}

input TomogramVoxelSpacingOrderByClause {
  run: RunOrderByClause
  voxelSpacing: orderBy
  s3Prefix: orderBy
  httpsPrefix: orderBy
  id: orderBy
}

input TomogramVoxelSpacingUpdateInput {
  runId: ID = null
  voxelSpacing: Float = null
  s3Prefix: String = null
  httpsPrefix: String = null
  id: Int = null
}

input TomogramVoxelSpacingWhereClause {
  annotationFiles: AnnotationFileWhereClause
  run: RunWhereClause
  tomograms: TomogramWhereClause
  voxelSpacing: FloatComparators
  s3Prefix: StrComparators
  httpsPrefix: StrComparators
  id: IntComparators
}

input TomogramVoxelSpacingWhereClauseMutations {
  id: IntComparators
}

input TomogramWhereClause {
  alignment: AlignmentWhereClause
  authors: TomogramAuthorWhereClause
  deposition: DepositionWhereClause
  run: RunWhereClause
  tomogramVoxelSpacing: TomogramVoxelSpacingWhereClause
  name: StrComparators
  sizeX: FloatComparators
  sizeY: FloatComparators
  sizeZ: FloatComparators
  voxelSpacing: FloatComparators
  fiducialAlignmentStatus: Fiducial_alignment_status_enumEnumComparators
  reconstructionMethod: Tomogram_reconstruction_method_enumEnumComparators
  processing: Tomogram_processing_enumEnumComparators
  tomogramVersion: FloatComparators
  processingSoftware: StrComparators
  reconstructionSoftware: StrComparators
  isCanonical: BoolComparators
  s3OmezarrDir: StrComparators
  httpsOmezarrDir: StrComparators
  s3MrcScale0: StrComparators
  httpsMrcScale0: StrComparators
  scale0Dimensions: StrComparators
  scale1Dimensions: StrComparators
  scale2Dimensions: StrComparators
  ctfCorrected: BoolComparators
  offsetX: IntComparators
  offsetY: IntComparators
  offsetZ: IntComparators
  affineTransformationMatrix: StrComparators
  keyPhotoUrl: StrComparators
  keyPhotoThumbnailUrl: StrComparators
  neuroglancerConfig: StrComparators
  tomogramType: Tomogram_type_enumEnumComparators
  isStandardized: BoolComparators
  id: IntComparators
}

input TomogramWhereClauseMutations {
  id: IntComparators
}

input Tomogram_processing_enumEnumComparators {
  _eq: tomogram_processing_enum
  _neq: tomogram_processing_enum
  _in: [tomogram_processing_enum!]
  _nin: [tomogram_processing_enum!]
  _gt: tomogram_processing_enum
  _gte: tomogram_processing_enum
  _lt: tomogram_processing_enum
  _lte: tomogram_processing_enum
  _is_null: Boolean
}

input Tomogram_reconstruction_method_enumEnumComparators {
  _eq: tomogram_reconstruction_method_enum
  _neq: tomogram_reconstruction_method_enum
  _in: [tomogram_reconstruction_method_enum!]
  _nin: [tomogram_reconstruction_method_enum!]
  _gt: tomogram_reconstruction_method_enum
  _gte: tomogram_reconstruction_method_enum
  _lt: tomogram_reconstruction_method_enum
  _lte: tomogram_reconstruction_method_enum
  _is_null: Boolean
}

input Tomogram_type_enumEnumComparators {
  _eq: tomogram_type_enum
  _neq: tomogram_type_enum
  _in: [tomogram_type_enum!]
  _nin: [tomogram_type_enum!]
  _gt: tomogram_type_enum
  _gte: tomogram_type_enum
  _lt: tomogram_type_enum
  _lte: tomogram_type_enum
  _is_null: Boolean
}

enum alignment_type_enum {
  LOCAL
  GLOBAL
}

enum annotation_file_shape_type_enum {
  SegmentationMask
  OrientedPoint
  Point
  InstanceSegmentation
}

enum annotation_file_source_enum {
  dataset_author
  community
  portal_standard
}

enum annotation_method_type_enum {
  manual
  automated
  hybrid
}

enum deposition_types_enum {
  annotation
  dataset
  tomogram
}

enum fiducial_alignment_status_enum {
  FIDUCIAL
  NON_FIDUCIAL
}

enum orderBy {
  asc
  asc_nulls_first
  asc_nulls_last
  desc
  desc_nulls_first
  desc_nulls_last
}

enum sample_type_enum {
  cell
  tissue
  organism
  organelle
  virus
  in_vitro
  in_silico
  other
}

enum tiltseries_microscope_manufacturer_enum {
  FEI
  TFS
  JEOL
}

enum tomogram_processing_enum {
  denoised
  filtered
  raw
}

enum tomogram_reconstruction_method_enum {
  SART
  Fourier_Space
  SIRT
  WBP
  Unknown
}

enum tomogram_type_enum {
  CANONICAL
  UNKNOWN
}
